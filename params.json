{
  "name": "Facebook-chef-cookbooks",
  "tagline": "",
  "body": "# Facebook Cookbooks Suite\r\n\r\n[![Build Status](https://travis-ci.org/facebook/chef-cookbooks.svg)](http://travis-ci.org/facebook/chef-cookbooks)\r\n\r\nThis repo contains attribute-driven-API cookbooks maintained by Facebook. It's\r\na large chunk of what we refer to as our \"core cookbooks.\"\r\n\r\nIt's worth reading our\r\n[Philosophy.md](https://github.com/facebook/chef-utils/blob/master/Philosophy.md)\r\ndoc before reading this. It covers how we use Chef and is important context\r\nbefore reading this.\r\n\r\nIt is important to note that these cookbooks are built using a very specific\r\nmodel that's very different from most other cookbooks in the community.\r\nSpecifically:\r\n\r\n* It assumes an environment in which you want to delegate. The cookbooks are\r\n  designed to be organized in a \"least specific to most specific\" order in the\r\n  runlist. The runlist starts with the \"core cookbooks\" that setup APIs and\r\n  enforce a base standard, which can be adjusted by the service owners using\r\n  cookbooks later in the runlist.\r\n* It assumes a \"run from master\" type environment. At Facebook we use [Grocery\r\n  Delivery](http://www.github.com/facebook/grocery-delivery) to sync the master\r\n  branch of our git repo with all of our Chef servers. Grocery Delivery is not\r\n  necessary to use these cookbooks, but since they were built with this model in\r\n  mind, the versions never change (relatedly: we do not use environments).\r\n* It assumes you have a testing toolset that allows anyone modifying later\r\n  cookbooks to ensure that their use of the API worked as expected on a live\r\n  node before committing. For this, we use [Taste\r\n  Tester](http://www.github.com/facebook/taste-tester).\r\n\r\n\r\n## APIs\r\n\r\nUnlike other cookbook models, we do not use resources as APIs, we use the node\r\nobject. Configuration is modeled in arrays and hashes as closely and thinly as\r\npossible to the service we are configuring. Ideally, you should only have to\r\nread the docs to the service to configure it, not the docs to the cookbook.\r\n \r\nFor example, if the service we are configuring has a key-value pair\r\nconfiguration file, we will provide a simple hash where keys and values will be\r\ndirectly put into the necessary configuration file.\r\n\r\nThere are two reasons we use attribute-driven APIs:\r\n\r\n1. Since our cookbooks are ordered least specific (core team that owns Chef) to\r\n   most specific (the team that owns this machine or service) it means that the\r\n   team who cares about this specific instance to always override anything. This\r\n   enables stacking that is not possible in many other models. For example, you\r\n   can have a runlist that looks like:\r\n\r\n   * Core cookbooks (the ones in this repo)\r\n   * Site/Company cookbooks (site-specific settings)\r\n   * Region cookbooks (overrides for a given region/cluster)\r\n   * Application Category cookbooks (webserver, mail server, etc.)\r\n   * Specific Application cookbook (\"internal app1 servier\")\r\n\r\n   So let's say that you want a specific amount of shared memory by default,\r\n   but in some region you know you have different size machines, so you shrink\r\n   it, but web servers need a further different setting, and then finally some\r\n   specific internal webserver needs an even more specific setting... this all\r\n   just works.\r\n\r\n   Further, a cookbook can see the value that was set before it modifies things,\r\n   so the 'webserver' cookbook could look to see if what the value was (small or\r\n   large) before modifying it and adjust it accordingly (so it could be relative\r\n   to the size of memory that the 'region' cookbook set.\r\n\r\n2. Allows for what we refer to as \"idempotent systems\" instead of \"idempotent\r\n   settings.\" In other words, if you only manage a specific item in a larger\r\n   config, and then you stop managing it, it should either revert to a\r\n   less-specific setting (see #1) or be removed, as necessary.\r\n\r\n   For example let's say you want to set a cron job. If you use the internal\r\n   cron resource, and then delete the recipe code that adds that cronjob, that\r\n   cron isn't removed from your production environment - it's on all existing\r\n   nodes, but not on any new nodes.\r\n\r\n   For this reason we use templates to take over a whole configuration wherever\r\n   possible. All cron jobs in our fb_cron API are written to\r\n   /etc/cron.d/fb_crontab - one you delete the lines adding a cronjob, since\r\n   they are just entries in a hash, when the template is generated on the next\r\n   Chef run, those crons go away.\r\n\r\n   Alternatively, consider a sysctl set by the \"site\" cookbook, then overwritten\r\n   but a later cookbook. When they remove that code, the entry in the hash is\r\n   now that set by the \"site\" cookbook. Automatically it falls back to the\r\n   next-most-specific value\r\n \r\n\r\n## Runlists\r\n\r\nHow you formulate your runlists is up to your site, as long as you follow the\r\nbasic rule that core cookbooks come first and you order least-specific to\r\nmost-specific. At Facebook, all of our runlists are:\r\n\r\n    recipe[fb_init], recipe[$SERVICE]\r\n\r\nWhere fb_init is similar to the sample provided in this repo, but with extra\r\n\"core cookbooks.\"\r\n\r\nWe generally think of this way: fb_init should make you a \"Facebook server\" and\r\nthe rest should make you a whatever-kind-of-server-you-are.\r\n\r\n\r\n## Getting started\r\n\r\nGrab a copy of the repo, rename `fb_init_sample` to fb_init, and follow the\r\ninstructions in the README.md (coordinating guidance is in comments in the\r\ndefault recipe).\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}